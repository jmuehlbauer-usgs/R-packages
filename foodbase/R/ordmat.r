#' @title Create a matrix of specimen data

#' @description Takes data from sampspec and builds ordination-friendly matrices of counts, mean/median/SD sizes, or biomasses, by taxon and sample.

#' @param sampspec The name of the \code{sampspec} list output containing sample and specimen information for building the matrix.
#' @param type The type of matrix output desired. See details. The default, \code{count}, creates a matrix of count data by taxon and sample.

#' @details
#' This function will likely only work with \code{sampspec} set to an output generated by the companion \code{\link{sampspec}} function, and with \code{sampspec(..., stats = TRUE)}. If you are working with data that do not have measured sizes and only counts (e.g., light trap data), then biomass and size matrices cannot be made and will return an error.
#'
#' The \code{type} argument can be specified to return a matrix of counts (\code{count}), biomass (\code{biomass}), or mean, median, or standard deviation in sizes (\code{sizemean}, \code{sizemed}, \code{sizesd}, respectively).
#'
#' Note on units: All biomass values are in \code{mg}, and sizes are in \code{mm}.

#' @return Creates a dataframe where each row is a sample and each column is a taxon.

#' @seealso \code{\link{sampspec}}, for creating the input list required for making \code{ordmat} work.

#' @concept access, database, ordination

#' @examples
#' ## Read in drift sample data from the network (all the defaults).
#' foo <- readDB()
#'
#' ## Subset only data from Lees Ferry
#' foo2 <- foo[foo$Reach == "CRLeesFerry",]
#'
#' ## Get the specimen data for these samples, all wrapped together and formatted nicely.
#' foo3 <- sampspec(samp = foo2)
#'
#' ## Create an ordination matrix of biomass data
#' myout <- ordmat(sampspec = foo3, type = "biomass")

#' @author Jeffrey D. Muehlbauer, \email{jmuehlbauer@usgs.gov}

#' @export

# Function call
ordmat <- function(sampspec, type = 'count'){

  # Throw error is sampspec was not run with summary statistics
  if(is.null(dim(sampspec$Statistics))){
    argnames <- sys.call()
    varname <- unlist(lapply(argnames[2], as.character))
    stop(paste(varname, "does not have statistics computed. This function won't work without them.\n  Please re-run sampspec, e.g., ", varname, "<- sampspec(..., stats = TRUE)."))
  }

  # Matrices for counts, size means, medians, standard deviations, and biomass
  mat0 <- matrix(data = 0, nrow = dim(sampspec$Samples)[1], ncol = dim(sampspec$Taxa)[1])
  dimnames(mat0) <- list(sort(sampspec$Samples$BarcodeID), sort(sampspec$Taxa$SpeciesID))
  if(type == 'count'){
    mat0[as.matrix(sampspec$Specimens[1:2])] <- sampspec$Statistics$CountTotal
    dat1 <- as.data.frame(mat0)
  } else {
    mat0[mat0 == 0] <- NA
    if(type == 'sizemean'){
      mat0[as.matrix(sampspec$Specimens[1:2])] <- sampspec$Statistics$SizeMean
      dat1 <- as.data.frame(mat0)
    }
    if(type == 'sizemed'){
      mat0[as.matrix(sampspec$Specimens[1:2])] <- sampspec$Statistics$SizeMedian
      dat1 <- as.data.frame(mat0)
    }
    if(type == 'sizesd'){
      mat0[as.matrix(sampspec$Specimens[1:2])] <- sampspec$Statistics$SizeSD
      dat1 <- as.data.frame(mat0)
    }
    if(type == 'biomass'){
      mat0[as.matrix(sampspec$Specimens[1:2])] <- sampspec$Statistics$BiomassTotal
      dat1 <- as.data.frame(mat0)
    }
  }
  dat2 <- dat1[, colSums(is.na(dat1)) < dim(dat1)[1]]
  if('NOBU' %in% colnames(dat2)){
    dat2 <- dat2[, -which(colnames(dat2) == 'NOBU')]
  }
  dat2 <- droplevels(dat2)

  # Close function
  return(dat2)
}
